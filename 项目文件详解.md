# 项目文件详解

> 本文档详细说明项目中每个文件的作用、核心逻辑及相互关系。

---

## 目录

- [一、项目总体架构](#一项目总体架构)
- [二、根目录文件](#二根目录文件)
- [三、核心引擎层 (`src/`)](#三核心引擎层-src)
- [四、后端服务层 (`backend/`)](#四后端服务层-backend)
- [五、前端展示层 (`frontend/`)](#五前端展示层-frontend)
- [六、数据流完整链路](#六数据流完整链路)

---

## 一、项目总体架构

本项目是一个集 **多智能体安全告警分析** 与 **RAG 知识库问答** 于一体的系统，采用前后端分离的三层架构：

```
┌──────────────────────────────────────────────────────────────────────┐
│  前端 (Streamlit)                              端口: 8501             │
│  ├─ 🔍 告警分析页面   ├─ 📊 分析历史页面                               │
│  ├─ 📚 RAG 问答页面   └─ 📈 系统仪表板页面                             │
├──────────────────────────────────────────────────────────────────────┤
│  后端 API (FastAPI)                            端口: 8000             │
│  ├─ /api/analyze     → 多智能体告警分析                                │
│  ├─ /api/history     → 历史记录查询                                    │
│  ├─ /api/stats       → 系统统计                                       │
│  ├─ /api/health      → 健康检查                                       │
│  └─ /api/rag/*       → RAG 文档入库 / 问答 / 管理                      │
├──────────────────────────────────────────────────────────────────────┤
│  核心引擎                                                              │
│  ├─ 多智能体系统 (src/)                                                │
│  │    ├─ RouterAgent    → 基于关键词+正则的告警分类路由                  │
│  │    └─ ExpertAgent×3  → 调用远程 Qwen LLM 进行深度安全分析            │
│  └─ RAG 服务 (backend/services/rag_service.py)                       │
│       ├─ Qwen3-Embedding-8B → 文本向量化                              │
│       └─ ChromaDB          → 本地持久化向量库 + 相似度检索              │
└──────────────────────────────────────────────────────────────────────┘
```

**技术栈：** Python · FastAPI · Streamlit · Qwen LLM · Qwen3-Embedding-8B · ChromaDB · Pydantic · Plotly · Docker

---

## 二、根目录文件

### `start_backend.py` — 后端本地启动脚本

- 将项目根目录加入 `sys.path`，确保模块导入正确
- 从 `BackendConfig` 读取主机/端口，调用 `uvicorn.run()` 启动 FastAPI 服务
- **启动命令**（本地开发）：`python start_backend.py`

---

### `start_frontend.py` — 前端本地启动脚本

- 定位 `frontend/app.py` 的绝对路径
- 通过 `subprocess.run()` 调用 `streamlit run`，指定端口 8501
- **启动命令**（本地开发）：`python start_frontend.py`

---

### `requirements.txt` — Python 依赖清单

| 分类 | 依赖 | 用途 |
|------|------|------|
| 核心 | `python-dotenv` | 加载 `.env` 环境变量 |
| 核心 | `openai` | OpenAI 兼容 SDK（RAG Embedding API 调用） |
| 核心 | `loguru` | 高级日志框架 |
| 后端 | `fastapi` / `uvicorn` | 异步 Web 框架 + ASGI 服务器 |
| 后端 | `pydantic` | 数据验证与序列化 |
| 后端 | `httpx` | 异步 HTTP 客户端（调用远程 LLM） |
| 前端 | `streamlit` | 多页面 Web UI |
| 前端 | `plotly` / `pandas` | 图表 + 数据处理 |
| 前端 | `requests` | 同步 HTTP（前端→后端） |
| 异步 | `aiohttp` | 异步 HTTP 支持 |
| RAG | `chromadb` | 本地持久化向量数据库 |

---

### `.env` — 环境变量配置

- **必填**：`LLM_API_KEY`、`MODEL_NAME`、`MODEL_URL`（LLM 对话模型配置）
- **RAG 必填**：`EMBEDDING_API_KEY`、`EMBEDDING_MODEL`、`EMBEDDING_URL`
- **可选**：`API_HOST`、`API_PORT`、`API_RELOAD`、`LOG_LEVEL`
- 此文件已加入 `.gitignore`，不会提交到版本控制

---

### `Dockerfile` — 镜像构建配置

- 基础镜像：`python:3.11-slim`
- 安装系统依赖：`supervisor`
- 安装 Python 依赖：`pip install -r requirements.txt`
- 使用 `supervisord` 同时管理后端和前端进程（见 `supervisord.conf`）

---

### `docker-compose.yml` — 容器编排配置

- 端口映射：`8000:8000`（后端）、`8501:8501`（前端）
- 通过 `env_file: .env` 注入环境变量
- Volume 挂载：`./logs:/app/logs`（日志持久化）、`./chroma_db:/app/chroma_db`（RAG 向量库持久化）

---

### `supervisord.conf` — 进程管理配置

- 同时管理两个进程：
  - `[program:backend]`：运行 `python start_backend.py`
  - `[program:frontend]`：运行 `streamlit run frontend/app.py --server.port=8501 --server.address=0.0.0.0 --server.headless=true`
- 日志分别输出到 `/app/logs/backend.log` 和 `/app/logs/frontend.log`

---

## 三、核心引擎层 (`src/`)

### `src/agents/optimized_router.py` — 路由智能体 ⭐

**类：** `OptimizedRouterAgent`

- 维护三大攻击类别的匹配规则（`routing_rules` 字典）：
  - `web_attack`：关键词（sql、xss、inject…）+ 正则（`UNION SELECT`、`<script>`…）
  - `vulnerability_attack`：关键词（cve、exploit、shellcode…）
  - `illegal_connection`：关键词（c2、botnet、ddos…）
- 评分机制：关键词命中 × 0.6 权重 + 正则命中 × 0.4 权重，取最高分类别
- 正则表达式在初始化时预编译（`re.compile`），避免重复编译开销
- `route()` 为 `async` 方法，与 FastAPI 异步生态兼容

---

### `src/agents/optimized_expert.py` — 专家智能体 ⭐

**类：** `OptimizedExpertAgent`

三种专家类型及对应领域：

| 类型 | 专家角色 | 分析场景 |
|------|---------|---------|
| `web_attack` | Web 安全专家 | SQL注入、XSS、命令注入、目录遍历、Webshell |
| `vulnerability_attack` | 漏洞分析专家 | CVE漏洞、Shellcode、缓冲区溢出、Exploit |
| `illegal_connection` | 网络通信专家 | C2通信、僵尸网络、DDoS、代理隧道 |

核心逻辑：
1. 从 `prompt_templates` 选取对应领域的提示词模板
2. 调用 `LLMInference.generate_response()` 请求远程 Qwen LLM
3. 从响应中提取 JSON 结构化结果（攻击技术、风险评分、威胁等级、建议）
4. **LLM 失败时自动降级**为 `_rule_based_analysis()`，基于关键词给出预设分析结果

---

### `src/agents/optimized_system.py` — 多智能体协调器 ⭐

**类：** `MultiAgentSystem`

- `initialize()`：创建 1 个路由智能体 + 3 个专家智能体 + 结构化日志记录器
- `analyze()` 三阶段流程：
  1. 路由决策：`RouterAgent.route()` → 确定攻击类别
  2. 专家分析：根据路由选择对应专家，`ExpertAgent.analyze()` → LLM 深度分析
  3. 结果综合：汇总 `task_id`、路由信息、专家分析、性能指标，返回完整结果字典

---

### `src/models/api_client.py` — 异步 LLM API 客户端

**类：** `APIClient`

- 使用 `httpx.AsyncClient` 异步调用 SiliconFlow/Qwen API
- `generate()`：调用 `/chat/completions`，文本生成超时 60s
- `get_embedding()`：调用 `/embeddings`，向量获取超时 30s
- 从 `.env` 读取 API Key、模型名称、API URL

---

### `src/models/llm_inference.py` — LLM 推理封装

**类：** `LLMInference`（全局单例，通过 `get_llm_inference()` 获取）

- 对 `APIClient` 的高层封装，提供 `generate_response()` 和 `get_embedding()` 异步方法
- 全局共享单例实例（`_GLOBAL_CLIENT`），避免重复创建 HTTP 客户端

---

### `src/utils/config.py` — 配置读取

- 从 `.env` 加载 `LLM_API_KEY`、`MODEL_NAME`、`MODEL_URL` 等配置，供 `src/` 层使用

---

### `src/utils/structured_logger.py` — 结构化日志

- 以 JSONL 格式实时追加日志到 `logs/analysis_YYYYMMDD_HHMMSS.jsonl`
- 追踪完整分析链路（路由决策、专家调用、token 统计、耗时）
- `save()` 生成 `.summary.json` 汇总文件

---

## 四、后端服务层 (`backend/`)

### `backend/config.py` — 后端配置管理

**类：** `BackendConfig`（类属性，模块加载时初始化）

| 配置字段 | 来源 | 说明 |
|---------|------|------|
| `LLM_API_KEY` / `MODEL_NAME` / `MODEL_URL` | `.env` | LLM 对话模型配置 |
| `EMBEDDING_API_KEY` / `EMBEDDING_MODEL` / `EMBEDDING_URL` | `.env` | RAG Embedding 配置 |
| `CHROMA_DB_PATH` | 计算得出 | ChromaDB 持久化路径（项目根目录下 `chroma_db/`） |
| `API_HOST` / `API_PORT` / `API_RELOAD` | `.env` | 后端服务配置 |
| `CORS_ORIGINS` | 硬编码 + `.env` | 允许的跨域来源 |

`validate()` 方法在应用启动时检查 `LLM_API_KEY`、`MODEL_NAME`、`MODEL_URL` 是否已设置。

---

### `backend/main.py` — FastAPI 主应用 ⭐

- `lifespan()` 生命周期管理器：启动时验证配置 → 初始化智能体服务 → 服务就绪
- 配置 CORS 中间件（允许 Streamlit 前端跨域访问）
- 注册三个路由模块：`analysis`（分析+历史）、`stats`（统计+健康检查）、`rag`（RAG 功能）

---

### `backend/api/models/schemas.py` — API 数据模型

Pydantic 模型，用于 API 请求/响应的数据校验：

| 模型 | 用途 |
|------|------|
| `AlertData` | 告警输入（`attack_type`、`payload`、`source_ip`、`dest_ip`） |
| `RoutingInfo` | 路由结果（`selected_route`、`confidence`） |
| `ExpertAnalysis` | 专家分析（`attack_technique`、`risk_score`、`threat_level`、`recommendations`） |
| `PerformanceMetrics` | 性能指标（各阶段耗时 ms） |
| `AnalysisResult` | 完整分析结果（组合以上子模型） |
| `AnalysisHistory` | 历史记录条目 |
| `SystemStats` | 系统统计（总数、威胁等级分布、攻击类型分布） |

---

### `backend/api/routes/analysis.py` — 告警分析路由

| 端点 | 方法 | 功能 |
|------|------|------|
| `/api/analyze` | POST | 接收告警 → 调用智能体服务 → 返回分析结果 |
| `/api/history` | GET | 查询历史（支持分页、按威胁等级/攻击类型/时间过滤） |

---

### `backend/api/routes/stats.py` — 统计路由

| 端点 | 方法 | 功能 |
|------|------|------|
| `/api/stats` | GET | 返回总分析次数、威胁等级分布、攻击类型分布 |
| `/api/health` | GET | 健康检查，返回服务状态和版本 |

---

### `backend/api/routes/rag.py` — RAG 路由 ⭐

| 端点 | 方法 | 功能 |
|------|------|------|
| `/api/rag/upload` | POST | 接收文本列表，分块入库 |
| `/api/rag/query` | POST | 知识库问答（检索 + LLM 生成） |
| `/api/rag/clear` | DELETE | 清空向量库 |
| `/api/rag/stats` | GET | 知识库统计（文档块数量、模型信息） |

---

### `backend/services/agent_service.py` — 智能体服务 ⭐

**类：** `AgentService`（全局单例，通过 `get_agent_service()` 获取）

- `initialize()`：创建并初始化 `MultiAgentSystem`
- `analyze_alert()`：将 Pydantic `AlertData` 转为字典 → 调用多智能体分析 → 保存到 `MemoryStorage` → 返回 `AnalysisResult`
- `get_analysis_history()` / `get_stats()`：委托给 `MemoryStorage` 查询

---

### `backend/services/memory_storage.py` — 内存历史存储

**类：** `MemoryStorage`（全局单例，通过 `get_memory_storage()` 获取）

- 在内存列表中存储告警分析历史（最多 100 条，最新优先）
- 支持按威胁等级、攻击类型、时间范围过滤 + 分页
- **注意**：数据仅在内存中，服务重启后丢失

---

### `backend/services/rag_service.py` — RAG 核心服务 ⭐

**类：** `RAGService`（全局单例，通过 `get_rag_service()` 获取）

核心功能：

| 方法 | 功能 |
|------|------|
| `_split_text(text)` | 将长文本按 500 字/块分块，相邻块 50 字重叠 |
| `_get_embeddings(texts)` | 批量调用 SiliconFlow Qwen3-Embedding-8B API |
| `add_documents(texts, source_name)` | 分块 → 向量化 → 存入 ChromaDB |
| `retrieve(question, top_k)` | 问题向量化 → ChromaDB 余弦相似度检索 → 返回 top-k 块 |
| `query_and_generate(question)` | 完整 RAG 流程：检索 → Context 拼接 → LLM 生成答案 |
| `clear()` | 清空向量库（删除并重建 Collection） |
| `get_stats()` | 返回文档块数量、Embedding 模型信息 |

---

## 五、前端展示层 (`frontend/`)

### `frontend/app.py` — Streamlit 主页面 ⭐

- 系统欢迎页，展示四大功能模块介绍（分析、历史、RAG、仪表板）
- 侧边栏显示后端连接状态（调用 `/api/health`）和技术栈信息

---

### `frontend/pages/1_🔍_Alert_Analysis.py` — 告警分析页面 ⭐

- 内置 7 种攻击类型预设示例，一键加载到表单
- 表单提交 → `POST /api/analyze` → 展示分析结果：
  - 关键指标（任务ID、威胁等级、风险评分、处理耗时）
  - 三个 Tab：专家分析 / 路由决策 / 性能指标
  - 完整 JSON 展开区

---

### `frontend/pages/2_📊_Analysis_History.py` — 分析历史页面

- 按威胁等级、攻击类型过滤历史记录
- 使用 Pandas DataFrame 表格展示，支持多维度浏览

---

### `frontend/pages/3_📚_RAG_问答.py` — RAG 知识库问答页面 ⭐

左侧文档上传（两种方式）：
- **粘贴文本**：直接在文本框输入，设置文档名称，点击「入库」
- **文件上传**：支持 `.txt`/`.md` 文件（UTF-8），预览前 500 字后入库

右侧问答区：
- 可调节 top_k 检索数量（1~8）
- 问答结果展示：LLM 生成答案 + 可折叠的参考文档片段（含来源名和相似度分数）
- 对话历史记录（最新在上），支持清空

侧边栏：知识库文档块数量、Embedding 模型信息、一键清空按钮

---

### `frontend/pages/4_📈_System_Dashboard.py` — 系统仪表板页面

- 关键指标：总分析次数、高危告警占比、攻击类型数
- Plotly 威胁等级环形饼图（颜色编码：高危-橙、中危-黄、低危-绿）
- Plotly 攻击类型分布柱状图

---

### `frontend/utils/api_client.py` — 前端 HTTP 客户端

**类：** `APIClient`（使用同步 `requests` 库，适配 Streamlit 同步运行模型）

| 方法 | 端点 | 说明 |
|------|------|------|
| `health_check()` | `GET /api/health` | 检查后端是否在线 |
| `analyze_alert()` | `POST /api/analyze` | 提交告警分析请求 |
| `get_analysis_history()` | `GET /api/history` | 获取分析历史 |
| `get_stats()` | `GET /api/stats` | 获取系统统计 |
| `rag_upload()` | `POST /api/rag/upload` | 上传文档文本入库 |
| `rag_query()` | `POST /api/rag/query` | 知识库问答 |
| `rag_clear()` | `DELETE /api/rag/clear` | 清空知识库 |
| `rag_stats()` | `GET /api/rag/stats` | 获取知识库统计 |

---

## 六、数据流完整链路

### 多智能体告警分析（以 SQL 注入为例）

```
用户提交告警 → 点击「开始分析」
  │
  ▼ frontend/utils/api_client.py  →  POST /api/analyze
  │
  ▼ backend/api/routes/analysis.py  →  analyze_alert()
  │
  ▼ backend/services/agent_service.py  →  analyze_alert()
  │
  ▼ src/agents/optimized_system.py  →  MultiAgentSystem.analyze()
  │
  ├─ 阶段1: RouterAgent.route()
  │    → 关键词「sql」命中 web_attack +0.6
  │    → 正则「UNION SELECT」命中 +0.4
  │    → 返回 {selected_route: "web_attack", confidence: 0.8}
  │
  ├─ 阶段2: ExpertAgent("web_attack").analyze()
  │    → 构造 Web攻击场景 Prompt
  │    → 调用 Qwen LLM API → 解析 JSON 结果
  │    → 返回 {attack_technique, risk_score, threat_level, recommendations}
  │
  └─ 阶段3: 汇总 { task_id, routing, expert_analysis, performance }
  │
  ▼ MemoryStorage.save_analysis()（保存到内存历史）
  │
  ▼ 返回 AnalysisResult → 前端展示
```

### RAG 问答（以"什么是 SQL 注入"为例）

```
用户输入文档 → 点击「入库」
  │
  ▼ POST /api/rag/upload  →  RAGService.add_documents()
  │    → 分块（500字/块）→ Qwen3-Embedding-8B 向量化 → ChromaDB 存储

用户输入问题 → 点击「提问」
  │
  ▼ POST /api/rag/query  →  RAGService.query_and_generate()
  │    → 问题向量化 → ChromaDB 余弦相似度 top-k 检索
  │    → 拼接 Context → 构建 Prompt（含文档片段）
  │    → Qwen LLM 生成答案
  │
  ▼ 返回 { answer, sources, has_context } → 前端展示（答案 + 参考片段）
```

---

> 📝 **文档版本**：2.0.0 | **更新时间**：2026-02-25
